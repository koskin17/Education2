/*
Заміна циклів за допомогою рекурсії
Рекурсія — це концепція того, що функція може бути виражена сама собою. Щоб краще зрозуміти, подумайте над наступним завданням: перемножте перші n елементи масиву, щоб отримати їх добуток. Ви могли б це зробити, використовуючи цикл for:

  function multiply(arr, n) {
    let product = 1;
    for (let i = 0; i < n; i++) {
      product *= arr[i];
    }
    return product;
  }
Проте, зверніть увагу, що multiply(arr, n) == multiply(arr, n - 1) * arr[n - 1]. Це означає, що ви можете переписати multiply у самій функції і ніколи не використовувати цикл.

  function multiply(arr, n) {
    if (n <= 0) {
      return 1;
    } else {
      return multiply(arr, n - 1) * arr[n - 1];
    }
  }
Рекурсивна версія multiply розбивається таким чином. У базовому випадку, де n <= 0, повертається 1. Функція викликає сама себе, якщо значення n більше, але n - 1. Цей виклик функції обчислюється так само, викликаючи multiply знову, доки n <= 0. На даному етапі всі функції можуть повертатися, а вихідна функція multiply повертає відповідь.

Примітка: рекурсивні функції повинні мати базовий випадок, коли вони повертаються без повторного виклику функції (у цьому прикладі, коли n <= 0), інакше вони ніколи не завершаться.

Напишіть рекурсивну функцію sum(arr, n), яка повертає суму перших n елементів масиву arr.
*/

function sum(arr, n) {
  // Базовий випадок: якщо n дорівнює 0, сума буде 0
  if (n <= 0) {
    return 0;
  } else {
    // Рекурсивний виклик: додаємо n-й елемент масиву до суми перших n-1 елементів
    return sum(arr, n - 1) + arr[n - 1];
  }
}

/*

Ось як можна написати рекурсивну функцію sum(arr, n), яка повертає суму перших n елементів масиву arr:

javascript
Копировать код
function sum(arr, n) {
  // Базовий випадок: якщо n дорівнює 0, сума буде 0
  if (n <= 0) {
    return 0;
  } else {
    // Рекурсивний виклик: додаємо n-й елемент масиву до суми перших n-1 елементів
    return sum(arr, n - 1) + arr[n - 1];
  }
}
Пояснення:
Базовий випадок: коли n дорівнює або менше 0, функція повертає 0. Це означає, що коли немає більше елементів для додавання, сума дорівнює 0.
Рекурсія: функція викликає саму себе, зменшуючи n на 1, доки не досягне базового випадку. Після кожного рекурсивного виклику функція додає поточний елемент масиву arr[n-1] до суми попередніх елементів.

Приклад використання:

javascript
Копировать код
console.log(sum([1, 2, 3, 4], 3)); // Поверне 6 (1 + 2 + 3)
Таким чином, функція рекурсивно обчислює суму перших n елементів масиву.
*/
