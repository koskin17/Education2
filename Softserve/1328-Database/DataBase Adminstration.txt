-- Посмотреть имеющиеся разрешения на конкретную таблицу
SELECT * FROM information_schema.role_table_grants
WHERE table_name = 'offers' AND table_schema = 'public'

-- Создать пользователя Базы Данных.
-- Пользователи не привязываются к конкретной schema. Они создаются в глобальном объекте.
-- После создания пользователя у тебя ещё нет никаких прав, т.е. он ничего делать с БД ничего не может.
CREATE USER patron WITH PASSWORD 'password';

-- Создание ролей
CREATE ROLE readonly;

CREATE ROLE readwrite;

-- Выдача ролей пользователям.
-- При этом важно помнить, что просто выдача роли пользователю недостаточно для того, чтобы он мог получить доступ к БД и совершать какие-то действия в БД.
GRANT readonly TO mykola;

GRANT readwrite TO patron;

-- К примеры, мы не хотим показывать кому-то информацию из таблицы БД.
-- И, к примеру, мы хотим дать доступ только к определённым колонкам: product_name и product_id
GRANT SELECT(product_id, product_name) ON products TO readonly;
-- В этом случае запрос пользователя SELECT * FROM products не сработает
-- А запрос SELECT product_id FROM products сработает
-- Также запрос SELECT не сработает на ту колонку, которая не была указана в GRANT SELECT(перечень колонок, к которым открывается доступ для роли с правами readonly)

-- На лекции не было возможности работать со схемой myshop (что-то не работало у преподавателя) и он предложил вариант создания VIEW для схемы myshop, чтобы пользователь мог всё-таки обратиться к таблицам схемы и получить какие-то данные, в соответствии со своими правами.
CREATE VIEW products_view AS (
  SELECT * FROM products
)
-- Но доступа к этой вьюшке у пользователя не было. Для предоставления доступа пользователю к вьюшке products_view выполнили команду:
GRANT SELECT ON products_view TO readonly;
-- Т.е. возможности читать информацию из таблицы не было, но мы дали права читать информацию из вьюшки.
-- В результате пользователь извне может сделать запрос SELECT * FROM products_view; к вьюшке и получить всю информацию, которая есть в вьюшке.
SELECT * FROM products_view;
-- Т.е. мы можем полностью запретить доступ к таблицам в БД, но сделать необходимые вьюшки и пользователям, в зависимсти от ролей, давать доступ к этим вьюшкам.
-- Так как у нас роль readonly и права только на чтение, то и запрос UPDATE не будет работать.

-- Теперь переходим к роли readwrite и даём доступ для этой роли на SELECT и на UPDATE, но UPDATE позволяем только определённых колонок.
GRANT SELECT, UPDATE(product_name) ON products TO readwrite;
-- В этом случае все пользователи, у которых есть роль readwrite получают возможность не только SELECT из products, но и возможность делать UPDATE, но только колонки products_name. Сделать UPDATE другим колонкам будет невозможно.

UPDATE products SET product_name = 'Tea' WHERE product_id = 1;

-- Дать разрешение на INSERT во все таблицы пользователям в ролью readwrite
GRANT INSERT ON ALL TABLES IN SCHEMA public TO readwrite;

-- Если же есть вьюшка из таблицы, для которой были удалены разрешения, то доступ к вьюшке всё-равно остаётся.

-- Удаление разрешений
-- Для удаления разрешения используется команда REVOKE:
	- REVOKE SELECT ON products FROM readonly; - удалить разрешение на SELECT в таблице products у роли readonly. Т.е. у всех пользователей с рлолью readonly будет удалено разрешение выполнять SELECT из таблицы products;
	- REVOKE INSERT ON titles FROM guest; - убрать разрешение на вставку данных в поле title у пользователей в ролью guest;
- Аналогично удаляется разрешение что-либо делать у конкретного пользователя:
	- REVOKE INSERT, UPDATE ON authors FROM mary; - удалить разрешение на INSERT и UPDATE таблицы authors у пользователя mary;
- Удаляем все разрешения у конкретного пользователя:
	- REVOKE ALL ON bussiness_book FROM mary; - удалить все разрешения для таблицы bussiness_book у пользователя mary
-- Удаляем всю роль для пользователя:
	-- REVOKE readwrite FROM patron; - удаление роли у конкретного пользователя;
-- Удалений всtq роли из Базы Данных:
	-- Если у роли есть permissions (разрешения), то сразу удалить роль не получится. Сначала надо удалить все permissions у роли: REVOKE ALL IN ALL TABLES IN SCHEMA public FROM readonly;
	-- Только потом выполнять команду удаления роли: DROP ROLE readonly;

-- Удаление пользователей из Базы Данных происходит аналогично:
-- DROP USER patron;

-- В Supabase есть надстройка или дополнительный функционал, который позволяет настроить permisions (размрешения) на уровне строк - RLS или Role Level Securities или Уровни Ролей. Т.е. можно указать какие именно строки и какие именно значения сможет быть та или иная роль. Это дополнительный, расширенный функционал.

-- Целостность данных
--- Транзакции.
---- Транзакции предназначены для сохранения целостности данных и Базы Данных в целом. Смысл транзакций в том, что они позволяют выполнять несколько операций как один единый блок, как бы одна команда, которая состоит из нескольких команд, которые должны выполниться поочередно. Т.е. этот блок или успешно выполняется, но обязательно весь, все команды внутри выполняются успешно, либо он возвращается исходное состояние, если какая-то из операций внутри этого блока не выполнилась. Т.е. при появлении хотя бы одной ошибки вся База Данных возвращается в первоначальное состояние, т.е. ничего не меняется, ни одна команда не выполняется.
---- Отметкой начала транзакции является команда BEGIN TRANSACTION; (это полное название), но чаще используют сокращённый вариант - просто BEGIN;.
---- В рамках транзакции можно выполнять любые команды / действия, которые позволены в SQL.
---- Если же мы решили, что транзакция была выполнена ошибочно и нам надо всё вернуть назад, то можно отменить выполнение транзакции, т.е. вернуть Базу Данных в состояние до транзакции. Для этого есть команда ROLLBACK;
---- Возврат действия транзакции возможно только до момента выполнения команды COMMIT;
---- Если после транзакции выполнена команда COMMIT; то отменить действие командой ROLLBAKC; уже невозможно. База Данных записывается в новом состоянии и никакой истории изменений не сохраняется.
---- Основной принцип транзакций заключается в принципах ACID.
---- Принципы ACID (Атомарность, Согласованность, Изолированность и Долговечность) обеспечивают надежность и целостность транзакций в базах данных.
		Атомарность (Atomicity): Каждая транзакция выполняется полностью или не выполняется вовсе. Представьте, что вы переводите деньги с одного банковского счета на другой. Если перевод не будет полностью завершен, то ни один из счетов не изменится. То есть, либо деньги списываются и зачисляются, либо ничего не происходит.
		Согласованность (Consistency): После завершения транзакции база данных должна остаться в согласованном состоянии. Это означает, что все правила и ограничения базы данных (например, уникальность ключей, ограничения по типам данных) будут соблюдены. Если транзакция нарушает эти правила, она откатывается назад.
		Изолированность (Isolation): Каждая транзакция выполняется так, как будто она единственная. Другие транзакции не видят ее промежуточных шагов. Это позволяет избежать конфликтов при одновременном выполнении нескольких транзакций. Например, если два человека одновременно пытаются купить тот же товар в интернет-магазине, изолированность гарантирует, что только один из них сможет успешно завершить покупку.
		При выполнении транзакции данные, с которым работает эта транзакция, как бы блокируются. Т.е. с ними никто другой ничего не может сделать. Если попытку как-то изменить эти данные будут, то придётся сначала дождаться завершения транзакции, которая работает с этими данными, а только потом уже эти данные станут доступны для какого-то еще изменения.
		Долговечность (Durability): После завершения транзакции ее результаты остаются сохраненными в базе данных, даже если произойдет сбой системы. То есть, если вы успешно сохранили данные в базе, они останутся там, независимо от возможных проблем с оборудованием или программным обеспечением.
		
---- Вставляем запись о том, что новый пользователь оформил новый заказ при помощи транзакции:
---- BEGIN;
	 -- Сначала вставляем нового пользователя в таблицу clients
	 INSERT INTO myshop.clients (name) VALUES ('Petro');
	 -- После добавляем запись о том, что он сразу оформляет заказ. При этом мы не знаем какой это клиент и в запросе INSERT в полях VALUES указываем номер заказ (order_id) = 3, а client_id выбираем подзапросом (выделяем его круглыми скобками "()") с условием, что нужен тот клиент, у которого имя равно Petro. Раз мы его только что вставили в таблицу clients, то SELECT найдёт этого пользователя и вернёт его client_id:
	 INSERT INTO myshop.orders (order_id, client_id) VALUES (3, (SELECT client_id FROM myshop.clients WHERE name = 'Petro'));
	 
	 -- Но представим, что что-то пошло не так и мы хотим сделать ROLLBACK; т.е. откатиться назад.
	 ROLLBACK;
	 
	 -- В этом случае транзакция отработаем верно, но никаких изменений в БД не произойдёт потому что отработала команда ROLLBAKC; и БД вернулась в состояние перед транзакцией.
	 -- Если же всё в порядке, то вместо ROLLBAKC; ставим команжу COMMIT; и фиксируем изменения, которые были сделаны в БД в рамках транзакции.
	 -- При этом в таблице clients у пользователя, которого мы внесли и внесение которого мы зафиксировали командой COMMIT; cleint_id будет равен 4. Это из-за того, что у client_id тип данных SERIAL и мы сначала вставили запись, т.е. следующий номер client_id был применён / использован, а потом мы отменили запись командой ROLLBACK;, но номер по порядку в SERIAL уже был использовал и доступным становится только следующий номер в SERIAL, т.е. "4". Из-за этого у пользователя, которого мы вставим после ROLLBACK; client_id уже будет "4".
--- SAVEPOINT в транзакциях.
--- SAVEPOINT позволяет внутри транзакции как-бы сохраниться. Т.е. можно выполнить какие-то действия в рамках транзакции, сохранить изменения на каком-то промежуточном этапе, а потом продолжить вносить изменения и если в них что-то пойдёт не так,то откатиться ROLLBACK; назад, но изменения до SAVEPOINT сохранятся в Базе Данных.
--- При этом ROLLBACK; позволяет "откатиться" полностью по всей транзакции или до конкретной точки SAVEPOINT.
	BEGIN;

	INSERT INTO myshop.clients (name) VALUES ('Maria');

	SAVEPOINT client_added;

	INSERT INTO myshop.orders (order_id, client_id) VALUES (4, (SELECT client_id FROM myshop.clients WHERE name = 'Maria'));

	ROLLBACK TO SAVEPOINT client_added;

	INSERT INTO myshop.orders (order_id, client_id) VALUES (5, (SELECT client_id FROM myshop.clients WHERE name = 'Maria'));

	COMMIT;
	
--- NOWAIT в транзакциях.
	NOWAIT используется в том случае, если есть вероятность того, что кто-то будет одновременно обращаться к одному полю в таблице, но необходимо несмотря на это иметь возможность обновить данные в этом поле.