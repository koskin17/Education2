/*
Використання рекурсії для створення зворотного відліку
У попередньому завданні ви дізнались, як використовувати рекурсію для заміни циклів for. Тепер розглянемо складнішу функцію, яка повертає масив послідовних цілих чисел, починаючи з 1 та закінчуючи переданим числом.

Як було згадано в попередньому завданні, ми матимемо базовий випадок. Він повідомляє рекурсивній функції, коли їй більше не потрібно викликати саму себе. Це простий випадок, коли повернене значення вже відоме. Також існує рекурсивний виклик, який виконує початкову функцію з різними аргументами. Якщо функція написана правильно, то буде досягнутий базовий випадок.

Скажімо, ви хочете написати рекурсивну функцію, що повертає масив, який містить числа від 1 до n. Цій функції потрібно прийняти аргумент n, який позначає кінцеве число. Тоді їй потрібно викликати саму себе, поступово зменшуючи значення числа n, поки воно не досягне 1. Ви можете написати функцію наступним чином:

function countup(n) {
  if (n < 1) {
    return [];
  } else {
    const countArray = countup(n - 1);
    countArray.push(n);
    return countArray;
  }
}
console.log(countup(5));
Консоль показуватиме значення [1, 2, 3, 4, 5].

Спочатку це може здатися парадоксальним, адже значення n зменшується, а значення у кінцевому масиві збільшується. Так відбувається через те, що збільшення відбувається останнім, після повернення рекурсивного виклику. На моменті, коли n поміщається у масив, countup(n - 1) вже проаналізовано та повернуто [1, 2, ..., n - 1].

Ми вже визначили функцію під назвою countdown з одним параметром (n). Функція повинна використовувати рекурсію, щоб повернути масив, який містить цілі числа від n до 1 на основі параметра n. Якщо функція викликається числом, меншим за 1, вона повинна повернути порожній масив. Наприклад, якщо викликати цю функцію із n = 5, повинен повернутися масив [5, 4, 3, 2, 1]. Ваша функція повинна використовувати рекурсію, викликаючи саму себе, та не повинна використовувати цикли.
*/

function countdown(n) {
  if (n < 1) {
    return [];
  } else {
    const countArray = countdown(n - 1); // Рекурсивний виклик
    countArray.unshift(n); // Додаємо n на початок масиву
    return countArray; // Повертаємо масив
  }
}

/*
// Приклад виклику функції
console.log(countdown(5)); // Виведе: [5, 4, 3, 2, 1]
console.log(countdown(3)); // Виведе: [3, 2, 1]
console.log(countdown(0)); // Виведе: []
Пояснення:
Базовий випадок: Якщо n < 1, функція повертає порожній масив.
Рекурсивний виклик: Функція викликає саму себе з n - 1.
Додавання до масиву: Після повернення рекурсивного виклику ми використовуємо метод unshift для додавання n на початок масиву, щоб зберегти порядок зворотного відліку.
Повернення масиву: Нарешті, функція повертає масив.
Таким чином, при кожному виклику зменшується значення n, поки не досягне базового випадку, після чого функція починає повертати масив, наповнюючи його числами від n до 1.
*/