import re
from collections import Counter

msg = "В розыгрыше победили: id1234563, id4653, id461"
# Нужно из сообщения msg извлечь айдишники победителей
# Это делает при помощи функции findall из модуля re
# передаётся "сырая" строка (r) и записывается:
# найти всё, что начинается с "id" и содержит любые цифры (\d) в любом количестве "+"
print(re.findall(r'id\d+', msg))

# найти в сообщении все хэштеги
tweet = "когда #эпидемия, то обязательно #оставайсядома"
# в метод findall передаётся строка tweet, в которой идёт поиск всех слов (\w) любой длины "+",
# начинающихся с "#"
print(re.findall(r'#\w+', tweet))

"""
Кванторы или quantifier
Применение строки re.findall(r'\w+', text) вернет все слова, предлоги и т.д. по отдельности из текста
Применение строки re.findall(r'\w*', text) вернет все слова, предлоги и т.д. + все пробельные символы.
Применение строки re.findall(r'\w?', text) вернет весь текст посимвольно, т.е. по одному символу
"""

# Нужно из строки с условными датами вытащить сами даты
registration = "Date of start: 4-12. Date of registration: 20-11"
# Ищем все числовые вхождения, состоящие из одной или двух цифр, которые написаны через тире "-".
# Обязательно соблюдает синтаксис изначального текста, т.е. не добавляем никаких побелов и ничего другого.
print(re.findall(r'\d{1,2}-\d{1,2}', registration))

# Вытащить номера телефонов из текста по соответствующему шаблону.
# Сначала прописываем шаблон, по которому будет поиск номера, а потом в методе re.findall указываем
# этот шаблон и текст, в котором надо найти номера телефонов.
phone_pattern = r'\+\d+-\d{3}-\d{3}-\d{2}-\d{2}'
phone_number = "Мой номер: +38-067-555-11-33, езе номер: +38-055-123-45-67, что-то и еще 0123ку-ку"
print(re.findall(phone_pattern, phone_number))

# Свалидировать дату, т.е. все даі в виде date должны пройти проверку
date = "1st september 2019 17:25"
print(re.findall(r'\d{1}\w+\s\w+\s\d{4}\s\d{2}\D{1,2}\d{1,2}', date))

# Посчитать кол-во лайков и репостов по всем сообщениям
messages = ['Опять дождь! Лайков: 5, Репостов: 4', 'Кутой был концерт! Лайков: 28, Репостов: 22']
likes = 0
repost = 0
# Создаём шаблон для лайков
likes_pattern = r'Лайков:\s\d+'
# Создаём шаблон для репостов
repost_pattern = r'Репостов:\s\d+'
# Циклом проходим по списку сообщений
for msg in messages:
    # Если в сообщении есть likes_pattern
    if re.findall(likes_pattern, msg):
        # Получаем список с элементами, в которых есть шаблон likes_pattern
        # print(re.findall(likes_pattern, msg))
        # Обращаемся в списке к элементу (у нас он первый и единственный
        # print(re.findall(likes_pattern, msg)[0])
        # И в этом первом (единственном) элементе ищем цифру
        # print(re.findall(r'\d+', re.findall(likes_pattern, msg)[0]))
        # Цифра возвращается тоже списком, в котором она - первый и единственный элемент
        # print(re.findall(r'\d+', re.findall(likes_pattern, msg)[0])[0])
        # Цифра является строкой - переформатируем и добавляем к счетчику лайков
        likes += int(re.findall(r'\d+', re.findall(likes_pattern, msg)[0])[0])
    #     аналогично по репостам
    if re.findall(repost_pattern, msg):
        repost += int(re.findall(r'\d+', re.findall(repost_pattern, msg)[0])[0])

print(likes)
print(repost)

# Из строки нужно выделить только восклицательные отзывы / предложения
tweet_2 = "Какое замечательное место! Обязательно вернусь сюда снова. Всем советую!!!"
# Применяется метод split из модуля re. Его отличие от split в базовом наборе Python в том, что он
# может применять в качестве разделителя сложные шаблоны.
# Возвращается список строк.
# В данном случае написано с "+" для того, чтобы обрабатывать несколько восклицательных знаков, которые
# могут быть в конце предложения. Также добавлен пробел, чтобы в итоговом списке по появлялась строка и
# предложения с воскл.знаком правильно отделялись друг от друга.
print(re.split(r'!+\s', tweet_2))
# Для получения кол-ва восклицательных предложений просто считается длина итогово списка, который
# возвращается методом split
print(len(re.split(r'!+\s', tweet_2)))
# Метод match ищет заданный шаблон в начале строки, т.е. ищет строку, которая начинается с указанного шаблона
# Метод search ищет шаблон во всем тексте и возвращает первое вхождение.
# В отличие от findall заключается в том, что findall возвращает список всех вхождений, а march и search возвращает
# сами объекты
text = "Что такое происходит?"
result = re.match('Что', text)
# В результате возвращается объект Match
print(result)
# У этого объекта есть поле match - само совпадение, т.е. сам запрос, который мы искали и поле span.
# Поле span указывает с какой по какую позиции находится match или наш запрос. Но "по какую" - не включается.
# Т.е. если span = (0, 3), то 3 не вклюается, т.е. запрос находится с 0-ой по 2-ю позицию
# Метод search ищет по всему тексту и возвращается аналогично match сам match-объект, т.е. наш запрос
# и поле span, в котором указаны индексу, по которым был найдет в тексте наш запрос.
result2 = re.search('происходит', text)
print(result2)
# Обратиться к значениям поля span можно методом start() (первое значение или начало) и методом end() - второе значение
# или конец позиции.
print("Начало вхождения слова \"происходит\" в позиции: ", result2.start())
print("Конец вхождения слова \"происходит\" в позиции:", result2.end())
print("Если точные позиции, то начало в позиции", result2.start(), ", а конец в позиции", result2.end() - 1)

# Метод group() возвращает сам запрос, а также может возвращать подшаблоны из шаблона.
# Метод sub() - это метод замены. Он ищет шаблон и заменяет его на указанную строку

# Определить, принадлежит ли домен зоне com.
domain = 'www.site.com'
# В данном случае точка "." - это не точка после www, а спец.символ, который обозначает любой символ после www и любой
# длины - "+".
# Т.е. запись ниже говорит: найти в domain все, что начинается с www + содержит любое кол-во символов и заканчивается
# на com
print(re.findall(r'www.+com', domain))
# Поиск только в начале и в конце строки
history_comment = "20 век был более опасным, чем 19 век"
# Выводится совпадение и в начале строки, и в конце строки
print(re.findall(r'\d{1,2}\s\век', history_comment))
# Поиск только в начале строки - выводит совпадение только в начале строки
print(re.findall(r'^\d{1,2}\s\век', history_comment))
# Поиск только в конце строки - выводит совпадение только в конце строки
print(re.findall(r'\d{1,2}\s\век$', history_comment))

# Нужно посчитать длину текста по кол-ву предложений. Предполагается, что предложения разделены только точкой "."
# Значит делить текст будем по точкам "."
text2 = """Давно выяснено, что при оценке дизайна и композиции читаемый текст мешает сосредоточиться.
Lorem Ipsum используют потому, что тот обеспечивает более или менее стандартное заполнение шаблона,
а также реальное распределение букв и пробелов в абзацах, которое не получается при простой дубликации.
 Многие программы электронной вёрстки и редакторы HTML используют Lorem Ipsum в качестве текста по умолчанию,
 так что поиск по ключевым словам "lorem ipsum" сразу показывает,
 как много веб-страниц всё ещё дожидаются своего настоящего рождения.
 За прошедшие годы текст Lorem Ipsum получил много версий. Некоторые версии появились по ошибке,
 некоторые - намеренно (например, юмористические варианты)."""
print(len(re.split(r'\.\s', text2)))

# Выбор "ИЛИ"
market_search = "Что лучше: ноутбук или компьютер?"
print(re.findall('ноутбук|компьютер', market_search))
# [] - поиск слова во всех склонениях
text3 = """Давно выяснено, что при оценке дизайна и композиции читаемый текст мешает сосредоточиться.
Lorem Ipsum используют потому, что тот обеспечивает более или менее стандартное заполнение шаблона,
а также реальное распределение букв и пробелов в абзацах, которое не получается при простой дубликации.
 Многие программы электронной вёрстки и редакторы HTML используют Lorem Ipsum в качестве текста по умолчанию,
 так что поиск по ключевым словам "lorem ipsum" сразу показывает,
 как много веб-страниц всё ещё дожидаются своего настоящего рождения.
 За прошедшие годы текст Lorem Ipsum получил много версий. Некоторые версии появились по ошибке,
 некоторые - намеренно (например, юмористические варианты)."""
# Ищем слова по шаблону: начинаются с "текст" и заканчиваются любыми буквами рус.алфавита в нижнем регистре любой длины
pattern = r'текст[а-я]+'
print(re.findall(pattern, text3))

# Инверсия.
# Если значок "^" стоит без квадратных скобок ([]), то он обозначает начало строки.
# Если же внутри квадратных скобок [^], то это обозначает инверсию или "не"
# Нужно найти все веб-адреса, в которых нет цифр.
websites = 'www.101.com www.google.com'
# В данном случае поиск всех строк по шаблону: начинается с www, дальше не содержит цифры от 0 до 9, любой длины
# и содержит com. Т.е. в данном случае значок "^" и запись [0-9] обозначает "не цифры"
print(re.findall(r'www[^0-9]+com', websites))

# Разделить текст по предложениям, независимо от знака на конце предложения
tweet_3 = "Какое замечательное место! Обязательно вернусь сюда снова!! Всем советую? Кто-то желает со мною??"
print(re.split(r'[.!?]+\s', tweet_3))
print(len(re.split(r'[.!?]+\s', tweet_3)))

# Регулярка должна валидировать пароль по следующим правилам:
# - только латинские буквы
# - содержит цифры
# - содержит символы *, #, $, %, !, &, .
# - длина от 8 до 20
passwords = ['Apple34!rose', 'My84hou#4$', 'abc123']
regex_pass = r'[\w*#$%!&.]{8,20}'
for password in passwords:
    if re.match(regex_pass, password):
        print(f"The password {password} is a valid password")
    else:
        print(f"The password {password} is invalid")

# Замена текста по шаблону на ЗАМЕНА
print(re.sub(r'текст\w*', 'ЗАМЕНА', text3))

# Скобочные группы
# Часть шаблона можно заключить в скобки (...). Это позволяет поместить часть шаблона в отдельную группу (структуру)
# Если установить квантификатор после скобок, то он будет применяться ко всему содержимому скобок, а не только к одному
# символу
# К подгруппам можно обращаться по порядковому номеру \1, \2, \3 и т.д.
# Группам можно давать имена в стиле (?P<имя>)
# Есть посадочный талон
flight = 'Boarding pass: LA4214 AER-CDB 06NOV'
# В нём:
# - первые 2 символа - аиакомпания,
# - 4 следующих - номер рейса,
# - 3 следующих - аэропорт отправления,
# - 3 следующих - аэропорт прибытия,
# - оставшиеся - дата рейса.
# Все буквы всегда в верхнем регистре.
# Пишем шаблон
# 1 группа (первые круглые скобки) - ищем первые две буквы лат.алфавита - это авиакомпания
# 2 группа (вторые круглые скобки) - это номер рейса
# пробельный символ
# 3 группа (третье кругл.скобки) - это аэропорт отправления
# дефис
# 4 группа (четвертые кругл.скобки) - аэропорт прибытия
# пробельный символ
# 5 группа (пятые скобки) - дата рейса
regex_flight = r'([A-Z]{2})(\d{4})\s([A-Z]{3})-([A-Z]{3})\s(\d{2}[A-Z]{3})'
# Валидация талона
flight_result = re.findall(regex_flight, flight)
# В результате мы получаем список, в котором каждое вхождение в виде кортежа из групп, которые мы сделали в шаблоне
# Значит каждая подгруппа имеет индекс и к ней можно обратиться.
print(re.findall(regex_flight, flight))
# Если применить метод search, то мы получим объект
flight_search_result = re.search(regex_flight, flight)
print(flight_search_result)
# Зная, что мы применили группы в шаблоне, а значит мы получаем кортежи, мы можем обратиться к группе по индексу.
# Например, нам нужна группа аэропрта отправления - она 3-ая
# Мы можем применить метод group() и указать группу, т.е. 3 или group(3)
print("Аэропорт отправления: ", flight_search_result.group(3))

# квартификатор внутри группы и после неё - совершенно разные вещи
numbers = "Мои счастливые числа 777 и 5534"
print(re.findall(r'\d+', numbers))
# Если \d поместить в отдельную группу в скобках () и после применить квантификатор,
# то получил последние символы последовательности
print(re.findall(r'(\d)+', numbers))
date = '08/30/1991'
print("Первоначальная дата: ", date)
# Для переформатирования в методе sub() мы указываем:
# - формат изначальной строки,
# - нужный формат, но указываем номера групп через точку. Т.е. к группам мы обращаемся по их порядковому номеру
# - переменную, в которой хранится дата
# Т.е. мы говорим поставить группу 2 на первое место, группу 1 на второе место и группу 3 в конец
print("Дата после переформатирования: ", re.sub(r'(\d{2})/(\d{2})/(\d{4})', r'\2.\1.\3', date))

# Удаляем повторяющиеся числа
numbers = "4444 55555 666666 7777777"
print("Изначальная строка с повторами чисел: ", numbers)
# Мы говорим: замени группу чисел (\d), повторяющихся n-раз "+" на саму первую группу \1, а сама первая группа у нас
# и есть то самое числа \d, которое находится внутри скобок ()
print("Строка без повторов числе: ", re.sub(r'(\d)+', r'\1', numbers))

# Non-capturing groups и lookarounds
# Non-capturing groups - это группы, которые можно найти, но не включать их в нужный шаблон.
# Lookarounds или позиционная проверка используется при поиске шаблона,
# которому обязательно предшестует или следует другой шаблон

# Пример non-capturing groups. Надо достать оценочные слова, которые стоят перед "фильм, кино"
review = "Мне очень понравился этот фильм! Понравилось еще расположение кинотеатра, очень удобное!"
# Мы ищем "понравился (фильм) или понравилось (кино)", после которых могут идти любые символы (точка ".") в любом
# количестве "+", но после этого обязательно есть группа "фильм" или "кино", которая должна быть, но она нам не нужна.
# А потом опять любые символы в любом количестве
regex_negative = r'(понравился|понравилось).+(?:фильм|кино).+'
negative_matches = re.findall(regex_negative, review)
# В итоге получаем только "понравился", которое стоит строго перед словом "фильм"
print(negative_matches)

# Пример lookarounds. Достанем имена только загруженых файлов
report = 'файл 111.txt загружен, файл 22.txt загружен, файл 33.txt ошибка'
find_downloaded = r'\d+\.txt(?=\sзагружен)'
files_error = r'\d+\.txt(?!\sзагружен)'
print("Загруженные файлы: ", re.findall(find_downloaded, report))
print("Файлы с ошибкой: ", re.findall(files_error, report))

# Получить только цены в долларах
prices = 'UAH5.55, USA10.88, GER0.99, USA5.21'
print(re.findall(r'USA\d+.\d+', prices))
# Вариант 2
print(re.findall(r'(?:USA)(\d+.\d+)', prices))
print(re.findall(r'(?<=USA)(\d+.\d+)', prices))