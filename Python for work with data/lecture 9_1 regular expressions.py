import re
from collections import Counter

msg = "В розыгрыше победили: id1234563, id4653, id461"
# Нужно из сообщения msg извлечь айдишники победителей
# Это делает при помощи функции findall из модуля re
# передаётся "сырая" строка (r) и записывается:
# найти всё, что начинается с "id" и содержит любые цифры (\d) в любом количестве "+"
print(re.findall(r'id\d+', msg))

# найти в сообщении все хэштеги
tweet = "когда #эпидемия, то обязательно #оставайсядома"
# в метод findall передаётся строка tweet, в которой идёт поиск всех слов (\w) любой длины "+",
# начинающихся с "#"
print(re.findall(r'#\w+', tweet))

"""
Кванторы или quantifier
Применение строки re.findall(r'\w+', text) вернет все слова, предлоги и т.д. по отдельности из текста
Применение строки re.findall(r'\w*', text) вернет все слова, предлоги и т.д. + все пробельные символы.
Применение строки re.findall(r'\w?', text) вернет весь текст посимвольно, т.е. по одному символу
"""

# Нужно из строки с условными датами вытащить сами даты
registration = "Date of start: 4-12. Date of registration: 20-11"
# Ищем все числовые вхождения, состоящие из одной или двух цифр, которые написаны через тире "-".
# Обязательно соблюдает синтаксис изначального текста, т.е. не добавляем никаких побелов и ничего другого.
print(re.findall(r'\d{1,2}-\d{1,2}', registration))

# Вытащить номера телефонов из текста по соответствующему шаблону.
# Сначала прописываем шаблон, по которому будет поиск номера, а потом в методе re.findall указываем
# этот шаблон и текст, в котором надо найти номера телефонов.
phone_pattern = r'\+\d+-\d{3}-\d{3}-\d{2}-\d{2}'
phone_number = "Мой номер: +38-067-555-11-33, езе номер: +38-055-123-45-67, что-то и еще 0123ку-ку"
print(re.findall(phone_pattern, phone_number))

# Свалидировать дату, т.е. все даі в виде date должны пройти проверку
date = "1st september 2019 17:25"
print(re.findall(r'\d{1}\w+\s\w+\s\d{4}\s\d{2}\D{1,2}\d{1,2}', date))

# Посчитать кол-во лайков и репостов по всем сообщениям
messages = ['Опять дождь! Лайков: 5, Репостов: 4', 'Кутой был концерт! Лайков: 28, Репостов: 22']
likes = 0
repost = 0
# Создаём шаблон для лайков
likes_pattern = r'Лайков:\s\d+'
# Создаём шаблон для репостов
repost_pattern = r'Репостов:\s\d+'
# Циклом проходим по списку сообщений
for msg in messages:
    # Если в сообщении есть likes_pattern
    if re.findall(likes_pattern, msg):
        # Получаем список с элементами, в которых есть шаблон likes_pattern
        # print(re.findall(likes_pattern, msg))
        # Обращаемся в списке к элементу (у нас он первый и единственный
        # print(re.findall(likes_pattern, msg)[0])
        # И в этом первом (единственном) элементе ищем цифру
        # print(re.findall(r'\d+', re.findall(likes_pattern, msg)[0]))
        # Цифра возвращается тоже списком, в котором она - первый и единственный элемент
        # print(re.findall(r'\d+', re.findall(likes_pattern, msg)[0])[0])
        # Цифра является строкой - переформатируем и добавляем к счетчику лайков
        likes += int(re.findall(r'\d+', re.findall(likes_pattern, msg)[0])[0])
#     аналогично по репостам
    if re.findall(repost_pattern, msg):
        repost += int(re.findall(r'\d+', re.findall(repost_pattern, msg)[0])[0])

print(likes)
print(repost)

# Из строки нужно выделить только восклицательные отзывы / предложения
tweet_2 = "Какое замечательное место! Обязательно вернусь сюда снова. Всем советую!!!"
# Применяется метод split из модуля re. Его отличие от split в базовом наборе Python в том, что он
# может применять в качестве разделителя сложные шаблоны.
# Возвращается список строк.
# В данном случае написано с "+" для того, чтобы обрабатывать несколько восклицательных знаков, которые
# могут быть в конце предложения. Также добавлен пробел, чтобы в итоговом списке по появлялась строка и
# предложения с воскл.знаком правильно отделялись друг от друга.
print(re.split(r'!+\s', tweet_2))
# Для получения кол-ва восклицательных предложений просто считается длина итогово списка, который
# возвращается методом split
print(len(re.split(r'!+\s', tweet_2)))
# Метод match ищет заданный шаблон в начале строки, т.е. ищет строку, которая начинается с указанного шаблона
# Метод search ищет шаблон во всем тексте и возвращает первое вхождение.
# В отличие от findall заключается в том, что findall возвращает список всех вхождений, а march и search возвращает
# сами объекты
text = "Что такое происходит?"
result = re.match('Что', text)
# В результате возвращается объект Match
print(result)
# У этого объекта есть поле match - само совпадение, т.е. сам запрос, который мы искали и поле span.
# Поле span указывает с какой по какую позиции находится match или наш запрос. Но "по какую" - не включается.
# Т.е. если span = (0, 3), то 3 не вклюается, т.е. запрос находится с 0-ой по 2-ю позицию
# Метод search ищет по всему тексту и возвращается аналогично match сам match-объект, т.е. наш запрос
# и поле span, в котором указаны индексу, по которым был найдет в тексте наш запрос.
result2 = re.search('происходит', text)
print(result2)
# Обратиться к значениям поля span можно методом start() (первое значение или начало) и методом end() - второе значение
# или конец позиции.
print("Начало вхождения слова \"происходит\" в позиции: ", result2.start())
print("Конец вхождения слова \"происходит\" в позиции:", result2.end())
print("Если точные позиции, то начало в позиции", result2.start(), ", а конец в позиции", result2.end()-1)

# Метод group() возвращает сам запрос, а также может возвращать подшаблоны из шаблона.
# Метод sub() - это метод замены. Он ищет шаблон и заменяет его на указанную строку

# Определить, принадлежит ли домен зоне com.
domain = 'www.site.com'
# В данном случае точка "." - это не точка после www, а спец.символ, который обозначает любой символ после www и любой
# длины - "+".
# Т.е. запись ниже говорит: найти в domain все, что начинается с www + содержит любое кол-во символов и заканчивается
# на com
print(re.findall(r'www.+com', domain))
# Поиск только в начале и в конце строки
history_comment = "20 век был более опасным, чем 19 век"
# Выводится совпадение и в начале строки, и в конце строки
print(re.findall(r'\d{1,2}\s\век', history_comment))
# Поиск только в начале строки - выводит совпадение только в начале строки
print(re.findall(r'^\d{1,2}\s\век', history_comment))
# Поиск только в конце строки - выводит совпадение только в конце строки
print(re.findall(r'\d{1,2}\s\век$', history_comment))

# Нужно посчитать длину текста по кол-ву предложений. Предполагается, что предложения разделены только точкой "."
# Значит делить текст будем по точкам "."
text2 = """Давно выяснено, что при оценке дизайна и композиции читаемый текст мешает сосредоточиться.
Lorem Ipsum используют потому, что тот обеспечивает более или менее стандартное заполнение шаблона,
а также реальное распределение букв и пробелов в абзацах, которое не получается при простой дубликации.
 Многие программы электронной вёрстки и редакторы HTML используют Lorem Ipsum в качестве текста по умолчанию,
 так что поиск по ключевым словам "lorem ipsum" сразу показывает,
 как много веб-страниц всё ещё дожидаются своего настоящего рождения.
 За прошедшие годы текст Lorem Ipsum получил много версий. Некоторые версии появились по ошибке,
 некоторые - намеренно (например, юмористические варианты)."""
print(len(re.split(r'\.\s', text2)))

# Выбор "ИЛИ"
market_search = "Что лучше: ноутбук или компьютер?"
print(re.findall('ноутбук|компьютер', market_search))
# [] - поиск слова во всех склонениях
text3 = """Давно выяснено, что при оценке дизайна и композиции читаемый текст мешает сосредоточиться.
Lorem Ipsum используют потому, что тот обеспечивает более или менее стандартное заполнение шаблона,
а также реальное распределение букв и пробелов в абзацах, которое не получается при простой дубликации.
 Многие программы электронной вёрстки и редакторы HTML используют Lorem Ipsum в качестве текста по умолчанию,
 так что поиск по ключевым словам "lorem ipsum" сразу показывает,
 как много веб-страниц всё ещё дожидаются своего настоящего рождения.
 За прошедшие годы текст Lorem Ipsum получил много версий. Некоторые версии появились по ошибке,
 некоторые - намеренно (например, юмористические варианты)."""
# Ищем слова по шаблону: начинаются с "текст" и заканчиваются любыми буквами рус.алфавита в нижнем регистре любой длины
pattern = r'текст[а-я]+'
print(re.findall(pattern, text3))

# Инверсия.
# Если значок "^" стоит без квадратных скобок ([]), то он обозначает начало строки.
# Если же внутри квадратных скобок [^], то это обозначает инверсию или "не"
# Нужно найти все веб-адреса, в которых нет цифр.
websites = 'www.101.com www.google.com'
# В данном случае поиск всех строк по шаблону: начинается с www, дальше не содержит цифры от 0 до 9, любой длины
# и содержит com. Т.е. в данном случае значок "^" и запись [0-9] обозначает "не цифры"
print(re.findall(r'www[^0-9]+com', websites))

# Разделить текст по предложениям, независимо от знака на конце предложения
tweet_3 = "Какое замечательное место! Обязательно вернусь сюда снова!! Всем советую? Кто-то желает со мною??"
print(re.split(r'[.!?]+\s', tweet_3))
print(len(re.split(r'[.!?]+\s', tweet_3)))
