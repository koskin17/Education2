DROP TABLE IF EXISTS book;

CREATE TABLE book
(
	book_id INT NOT NULL, -- Если указать INT, то это просто число, а если serial, то происходит автоинкремент
	title TEXT NOT NULL,
	isbn VARCHAR(32) NOT NULL,
	publisher_id INT NOT NULL,

	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id)
)

SELECT * FROM book

-- Аналог serial для book_id можно сделать при помощи генерации чисел. Т.е. создаётся SEQUENCE и назначается на поле
CREATE SEQUENCE IF NOT EXISTS book_book_id_seq -- Здесь создаётся последовательность с именем book_book_id_seq
START WITH 1 OWNED BY book.book_id -- Это и есть строчка назначения последовательности конкретному столбцу, которая начинается с 1
-- Если после этого выполнить добавление данных в БД, то получим ошибку.
-- INSERT INTO book(title, isbn, publisher_id)
-- VALUES ('title', 'isbn', 1)
-- Для того, чтобы её не было нужно навесить CONSTRAINT DEFAULT, которые, если ничего не вставляется, то вызывает функцию nextval на
-- созданной последовательности
ALTER TABLE book
ALTER COLUMN book_id SET DEFAULT nextval('book_book_id_seq')
-- Теперь, если данные добавляются в БД, то автогенерация и автоинкремент работает
INSERT INTO book(title, isbn, publisher_id)
VALUES ('title', 'isbn', 1);
SELECT * FROM book

-- Именно по принципу этих двух строк кода:
-- CREATE SEQUENCE IF NOT EXISTS book_book_id_seq -- Здесь создаётся последовательность с именем book_book_id_seq
-- START WITH 1 OWNED BY book.book_id
-- и работает типа данных serial в базе данных.
-- При это у serial есть одна проблема, о которой надо помнить.
-- При заполнении поля значениями serial в это поле можно самостоятельно вставить номер (следующий по порядку, к примеру):
-- INSERT INTO book(title, isbn, publisher_id)
-- VALUES (3, 'title', 'isbn', 1);
-- но после этого следующее поле serial:
-- INSERT INTO book(title, isbn, publisher_id)
-- VALUES ('title', 'isbn', 1);
-- уже не будет заполняться и будет выдавать ошибку.

-- Есть более современный подход для формирования SEQUENCE для поля с помощью:
-- GENERATED ALWAYS AS IDENTITY или GENERATED BY DEFAULT AS IDENTITY
-- К примеру:
DROP TABLE IF EXISTS book;

CREATE TABLE book
(
	book_id INT GENERATED ALWAYS AS IDENTITY NOT NULL,
	title TEXT NOT NULL,
	isbn VARCHAR(32) NOT NULL,
	publisher_id INT NOT NULL,

	CONSTRAINT PK_book_book_id PRIMARY KEY(book_id)
)

INSERT INTO book(title, isbn, publisher_id)
VALUES ('title', 'isbn', 1);
SELECT * FROM book

-- В этом случае всё работает, как и с serial, но теперь принудительно вставить вставить значение в поле для book_id нельзя и будет ошибка
-- Именно опцией ALWAYS запрещается для PostgreSQL давать возможность в ручном режиме прописывать номер.
-- Однако есть операция OVERRIDING SYSTEM VALUE, которая позволяет "впихивать" значения для поля serial вручную и обходить ограничения.
INSERT INTO book
OVERRIDING SYSTEM VALUE
VALUES (4, 'title', 'isbn', 1);
SELECT * FROM book

-- Дополнительные параметры для GENERATED ALWAYS AS IDENTITY NOT NULL
-- GENERATED ALWAYS AS IDENTITY (START WITH 10 INCREMENT BY 2) NOT NULL - старт с 0 и шаг равный 2

